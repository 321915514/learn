基础:

![1568132443134](assets/1568132443134.png)

singleton

单例设计模式

唯一

面试mq

![1568134763960](assets/1568134763960.png)

消息队列技术选型

为啥用,

解耦,异步,削峰



优点缺点



消息队列区别以及时合那些场景

java高并发

syc的原理

列举java中的锁



java设计模式



java线程池原理

数据结构



java混淆的概念

java框架篇

spring原理

springmvc和springboot的区别

对象原理:

当new 出来一个对象的时候,对象头的前56bit存的是 4 个存年龄,2个存锁的的状态,1个没用,一个偏向锁状态



2 个存同步状态

![1568208622925](assets/1568208622925.png)

![1568209200725](assets/1568209200725.png)

![1568209796370](assets/1568209796370.png)

![1568210079295](assets/1568210079295.png)

基础:

流程控制

顺序结构

从上到下

分支结构

if else

循环

while for

![1568212338857](assets/1568212338857.png)

基础

![1568215312969](assets/1568215312969.png)

![1568218101905](assets/1568218101905.png)

![1568218722363](assets/1568218722363.png)

Integer对象默认有-128-127的对象

![1568219448691](assets/1568219448691.png)

![1568219626997](assets/1568219626997.png)

![1568220102173](assets/1568220102173.png)

![1568220227924](assets/1568220227924.png)

stringbuffer没有重写equals方法

比较的object的对象引用

![1568220473499](assets/1568220473499.png)

true

![1568220678665](assets/1568220678665.png)

![1568221135496](assets/1568221135496.png)

![1568224232115](assets/1568224232115.png)

为什么读写分离

减少了主库读的压力



数据库的终极,分库分表

类型: 

垂直:

![1568823529923](assets/1568823529923.png)

水平:

![1568823550682](assets/1568823550682.png)

